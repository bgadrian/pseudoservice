/*
 * Pseudo Service
 *
 * Deterministic or pseudo-random data generator
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package users

import (
	"fmt"
	"math"
	"strings"
	"sync"

	"github.com/brianvoe/gofakeit"
)

type User struct {
	// UUID for this user
	Id       string `json:"id"`
	Age      uint8  `json:"age"`
	Name     string `json:"name"`
	Company  string `json:"company,omitempty"`
	Position string `json:"position,omitempty"`
	Email    string `json:"email,omitempty"`
	Country  string `json:"country,omitempty"`
	// Random list of UUIDs from the same response. To increase the chance of having friends request for bigger batches.
	Friends []string `json:"friends,omitempty"`
}

//TODO make it safe https://github.com/brianvoe/gofakeit/issues/32
var hackMutex sync.Mutex

//GenerateUsers deterministic generation of (random) users.
func GenerateUsers(seed int64, count int, deterministic bool) ([]*User, int64, error) {
	if math.MaxInt64-int64(count) <= seed {
		//chance to being here is like ... 2^63-count ...is like winning the lottery
		return nil, 0, fmt.Errorf("int overflow, need a smaller seed: %d count: %d", seed, count)
	}

	if deterministic {
		hackMutex.Lock()
		defer hackMutex.Unlock()
	}

	if deterministic == false {
		gofakeit.Seed(seed)
	}

	result := make([]*User, 0, count)
	friendsIndexs := make([]int, 0, count)

	for i := 0; i < count; i++ {
		//ALERT as long as the following lines remain in order, the calls will be deterministic/backward
		//compatible.

		if seed == 0 {
			seed++ //gofakeit treats 0 as newRandom
		}

		user := &User{}
		if deterministic {
			//each seed value must return a specific user, with same data
			//but the performance is 30% worst
			gofakeit.Seed(seed)
		}
		user.Id = gofakeit.UUID()
		user.Age = gofakeit.Uint8()
		user.Name = gofakeit.Name()
		user.Company = gofakeit.BuzzWord() + " " +
			gofakeit.BS() + " " + gofakeit.CompanySuffix()
		user.Position = gofakeit.JobDescriptor() + " " +
			gofakeit.JobLevel() + " " + gofakeit.JobTitle()

		user.Email = strings.Replace(user.Name, " ", "", -1) + "." + gofakeit.DomainSuffix()
		user.Country = gofakeit.Country()

		//FRIENDS from the same batch
		zeroTendency := len(result) / 3                              //at least 33% will have 0 friends
		friendCount := gofakeit.Number(-zeroTendency, len(result)/2) //max of half of users so far

		if friendCount > 0 {
			user.Friends = make([]string, 0, friendCount)
			fcount := 0
			//shuffle them more rarely, for perf reasons
			if i%10 == 0 {
				gofakeit.ShuffleInts(friendsIndexs)
			} else {
				//we do not shuffle it, but we start from a random friend
				fcount = gofakeit.Number(0, len(friendsIndexs)-friendCount-1)
			}

			for ; fcount < friendCount; fcount++ {
				friend := result[friendsIndexs[fcount]]
				user.Friends = append(user.Friends, friend.Id)   //him -> me
				friend.Friends = append(friend.Friends, user.Id) //me -> him
			}
		}

		seed++
		result = append(result, user)
		friendsIndexs = append(friendsIndexs, i)
	}
	return result, seed, nil
}
